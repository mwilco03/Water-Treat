name: Build and Release

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  BUILD_TYPE: Release

jobs:
  # Build for multiple architectures
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          # Native x86_64 build (for testing/CI)
          - arch: x86_64
            os: ubuntu-latest
            cross: false
            artifact_suffix: linux-x86_64

          # ARM64 (Raspberry Pi 3/4/5, Orange Pi, Le Potato)
          - arch: aarch64
            os: ubuntu-latest
            cross: true
            cross_compiler: aarch64-linux-gnu
            artifact_suffix: linux-arm64

          # ARM32 (Raspberry Pi 2, Zero, older boards)
          - arch: armhf
            os: ubuntu-latest
            cross: true
            cross_compiler: arm-linux-gnueabihf
            artifact_suffix: linux-armhf

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4

    - name: Install dependencies (native)
      if: ${{ !matrix.cross }}
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          libncurses5-dev \
          libsqlite3-dev \
          libcurl4-openssl-dev \
          libcjson-dev \
          libgpiod-dev \
          libsystemd-dev

    - name: Install cross-compilation toolchain
      if: ${{ matrix.cross }}
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          crossbuild-essential-${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }} \
          qemu-user-static

    - name: Install cross-compiled libraries
      if: ${{ matrix.cross }}
      run: |
        # Add architecture support
        sudo dpkg --add-architecture ${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }}

        # Update package lists for new architecture
        sudo apt-get update || true

        # Install cross-compiled development libraries
        sudo apt-get install -y \
          libncurses5-dev:${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }} \
          libsqlite3-dev:${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }} \
          libcurl4-openssl-dev:${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }} \
          libcjson-dev:${{ matrix.arch == 'aarch64' && 'arm64' || 'armhf' }} || true

    - name: Configure CMake (native)
      if: ${{ !matrix.cross }}
      run: |
        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DBUILD_TESTS=ON

    - name: Configure CMake (cross-compile)
      if: ${{ matrix.cross }}
      run: |
        # Create toolchain file
        cat > toolchain-${{ matrix.arch }}.cmake << 'EOF'
        set(CMAKE_SYSTEM_NAME Linux)
        set(CMAKE_SYSTEM_PROCESSOR ${{ matrix.arch }})

        set(CMAKE_C_COMPILER ${{ matrix.cross_compiler }}-gcc)
        set(CMAKE_CXX_COMPILER ${{ matrix.cross_compiler }}-g++)

        set(CMAKE_FIND_ROOT_PATH /usr/${{ matrix.cross_compiler }})
        set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
        set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
        set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)

        # Skip pkg-config for cross compilation
        set(PKG_CONFIG_EXECUTABLE /usr/bin/pkg-config)
        EOF

        cmake -B build \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_TOOLCHAIN_FILE=toolchain-${{ matrix.arch }}.cmake \
          -DBUILD_TESTS=OFF

    - name: Build
      run: cmake --build build --config ${{ env.BUILD_TYPE }} -j$(nproc)

    - name: Run tests (native only)
      if: ${{ !matrix.cross }}
      run: |
        cd build
        ctest --output-on-failure || true

    - name: Package binary
      run: |
        mkdir -p dist
        cp build/profinet-monitor dist/profinet-monitor-${{ matrix.artifact_suffix }}
        chmod +x dist/profinet-monitor-${{ matrix.artifact_suffix }}

        # Create tarball with supporting files
        mkdir -p package/systemd package/config
        cp build/profinet-monitor package/
        cp -r systemd/* package/systemd/ 2>/dev/null || true
        cp README.md OPERATOR.md LICENSE package/

        # Create install script
        cat > package/install.sh << 'INSTALL_EOF'
        #!/bin/bash
        set -e
        echo "Installing Water Treatment RTU..."

        # Install binary
        sudo install -m 755 profinet-monitor /usr/local/bin/

        # Create config directory
        sudo mkdir -p /etc/profinet-monitor
        sudo mkdir -p /var/lib/profinet-monitor

        # Install systemd service if available
        if [ -f systemd/profinet-monitor.service ]; then
            sudo cp systemd/profinet-monitor.service /etc/systemd/system/
            sudo systemctl daemon-reload
            echo "Installed systemd service. Enable with: sudo systemctl enable profinet-monitor"
        fi

        echo "Installation complete!"
        echo "Run 'profinet-monitor' to start, or enable the systemd service."
        INSTALL_EOF
        chmod +x package/install.sh

        tar -czvf dist/water-treat-${{ matrix.artifact_suffix }}.tar.gz -C package .

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: water-treat-${{ matrix.artifact_suffix }}
        path: dist/
        retention-days: 7

  # Create release when tagged
  release:
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Prepare release assets
      run: |
        mkdir -p release
        find artifacts -name "*.tar.gz" -exec cp {} release/ \;
        find artifacts -name "profinet-monitor-*" -exec cp {} release/ \;
        ls -la release/

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: release/*
        generate_release_notes: true
        draft: false
        prerelease: ${{ contains(github.ref, '-rc') || contains(github.ref, '-beta') || contains(github.ref, '-alpha') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
